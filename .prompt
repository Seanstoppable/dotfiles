#functions for showing git repo status on the command line

# * uncommitted changes
# ^ stashed changes
# > ahead of origin
# < behind origin
# ↕ diverged from origin
# R rebasing

function parse_git_dirty() {
  regex="working directory clean"
  if [[ $1 =~ $regex ]]
  then
    echo ""
  else
    echo "*"
  fi
}

function parse_git_rebasing() {
  regex="currently rebasing"
  if [[ $1 =~ $regex ]]
  then
    echo "R"
  else
    echo ""
  fi
}

function parse_git_stash (){
  stash=`git stash list 2> /dev/null | wc -l | tr -d ' '`
  
  [[ $stash != 0 ]] && echo "^$stash"
}

function parse_git_ahead() {
  regex="Your branch is ahead of [a-z'/]+ by ([0-9]+)"
  if [[ $1 =~ $regex ]]
  then
    n=${BASH_REMATCH[1]}
    echo ">$n"
  fi
}

function parse_git_behind() {
  regex="Your branch is behind [a-z'/]+ by ([0-9]+)"
  if [[ $1 =~ $regex ]]
  then
    n=${BASH_REMATCH[1]}
    echo "<$n"
  fi
}

function parse_git_diverge() {
  regex="([0-9]+) and ([0-9]+) different commits"
  if [[ $1 =~ $regex ]]
  then
    your=${BASH_REMATCH[1]}
    source=${BASH_REMATCH[2]}
    symbol="↕"
    echo "$your$symbol$source"
  fi
}

function current_git_branch() {
  git rev-parse --abbrev-ref HEAD 2> /dev/null
}

function current_git_branch_with_markers {
  current=`current_git_branch`
  if [[ $current ]] 
  then
    git_status=`git status 2> /dev/null`
    stash=`parse_git_stash`
    ahead=`parse_git_ahead "$git_status"`
    behind=`parse_git_behind "$git_status"`
    diverge=`parse_git_diverge "$git_status"`
    dirty=`parse_git_dirty "$git_status"`
    rebasing=`parse_git_rebasing "$git_status"`
    echo $current | sed -e "s/\(.*\)/ \[\1$ahead$behind$diverge$dirty$rebasing$stash\]/"
  fi
}

function set_prompt {
  local  GREEN='\[\e[0;32m\]'
  local    RED='\[\e[0;31m\]'
  local NORMAL='\[\e[0m\]'

  PS1="\h:\W \u\[\033[0;32m\]\$(current_git_branch_with_markers) \[\033[0m\]\$ "
}

set_prompt
